{"version":3,"sources":["components/WebCam.js","App.js","serviceWorker.js","index.js","assets/images/img_45.jpg"],"names":["WebCam","myYolo","colors","componentDidMount","_callee","regenerator_default","a","wrap","_context","prev","next","_this","setupCam","load","run","stop","this","_callee2","_context2","refs","canvas","width","webcam","videoWidth","height","videoHeight","getContext","drawImage","predict","setTimeout","_callee3","_context3","navigator","mediaDevices","getUserMedia","audio","video","facingMode","srcObject","sent","_callee4","start","boxes","end","_context4","performance","now","numClasses","classNames","console","log","concat","drawBoxes","rects","innerHTML","cw","clientWidth","ch","clientHeight","vw","vh","scaleW","scaleH","webcam_wrapper","style","map","box","Math","floor","random","toString","rect","document","createElement","className","top","left","borderColor","text","innerText","toFixed","color","appendChild","_callee5","_context5","dispose","yolo","v3tiny","process","react_default","id","ref","autoPlay","playsInline","muted","position","visibility","Component","App","components_WebCam","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","getElementById","serviceWorker","ready","then","registration","unregister","module","exports","__webpack_require__","p"],"mappings":"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","file":"static/js/main.9ca1216a.chunk.js","sourcesContent":["import React, {Component} from 'react';\nimport '../assets/styles/webcam.scss';\nimport yolo from 'tfjs-yolo';\n\nclass WebCam extends Component {\n\n    myYolo = null;\n    colors = {};\n\n    componentDidMount = async () => {\n        await this.setupCam();\n        this.load();\n        this.run();\n    };\n\n    run = async () => {\n        this.refs.canvas.width = this.refs.webcam.videoWidth;\n        this.refs.canvas.height = this.refs.webcam.videoHeight;\n        this.refs.canvas.getContext('2d').drawImage(this.refs.webcam, 0, 0, this.refs.webcam.videoWidth, this.refs.webcam.videoHeight);\n        if(this.myYolo && this.refs.canvas.width !== 0 && this.refs.canvas.height !== 0){\n            this.predict();\n        }\n        setTimeout(this.run, 500);\n    };\n\n    setupCam = async () => {\n        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n            this.refs.webcam.srcObject = await navigator.mediaDevices.getUserMedia({\n                'audio': false,\n                'video': { facingMode: 'environment' }\n            });\n        }\n    };\n\n    predict = async () => {\n        const start = performance.now();\n        const boxes = await this.myYolo(this.refs.canvas, { numClasses: 1, classNames: ['figure'] });\n        const end = performance.now();\n        console.log(`Inference took ${end - start} ms`);\n\n        this.drawBoxes(boxes);\n    };\n\n    drawBoxes = (boxes) => {\n        console.log(boxes);\n        this.refs.rects.innerHTML = '';\n\n        const cw = this.refs.webcam.clientWidth;\n        const ch = this.refs.webcam.clientHeight;\n        const vw = this.refs.webcam.videoWidth;\n        const vh = this.refs.webcam.videoHeight;\n\n        const scaleW = cw / vw;\n        const scaleH = ch / vh;\n\n        this.refs.webcam_wrapper.style.width = `${cw}px`;\n        this.refs.webcam_wrapper.style.height = `${ch}px`;\n\n        boxes.map((box) => {\n            if (!(box['class'] in this.colors)) {\n                this.colors[box['class']] = '#' + Math.floor(Math.random() * 16777215).toString(16);\n            }\n\n            const rect = document.createElement('div');\n            rect.className = 'rect';\n            rect.style.top = `${box['top'] * scaleH}px`;\n            rect.style.left = `${box['left'] * scaleW}px`;\n            rect.style.width = `${box['width'] * scaleW - 4}px`;\n            rect.style.height = `${box['height'] * scaleH - 4}px`;\n            rect.style.borderColor = this.colors[box['class']];\n\n            const text = document.createElement('div');\n            text.className = 'text';\n            text.innerText = `${box['class']} ${box['score'].toFixed(2)}`;\n            text.style.color = this.colors[box['class']];\n\n            rect.appendChild(text);\n            this.refs.rects.appendChild(rect);\n            return box;\n        });\n    };\n\n    load = async () => {\n        if (this.myYolo){\n            this.myYolo.dispose();\n            this.myYolo = null;\n        }\n        this.refs.rects.innerHTML = '';\n        this.myYolo = await yolo.v3tiny(process.env.PUBLIC_URL + '/model/model.json');\n    };\n\n\n    render() {\n        return (\n            <div className=\"container\">\n                <div id=\"webcam-wrapper\" ref=\"webcam_wrapper\">\n                    <div ref=\"rects\" id=\"rects\"/>\n                    <video autoPlay playsInline muted ref=\"webcam\" id=\"webcam\"/>\n                    <canvas ref=\"canvas\" style={{position: \"absolute\", visibility: \"hidden\"}}/>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default WebCam;\n","import React, {Component} from 'react';\nimport './App.css';\nimport test_img from './assets/images/img_45.jpg';\nimport yolo from 'tfjs-yolo';\nimport WebCam from './components/WebCam';\n\nclass App extends Component {\n    //\n    // async componentDidMount() {\n    //     const canvas = document.getElementById('canvas');\n    //     const ctx = canvas.getContext('2d');\n    //     let myYolo = await yolo.v3tiny(process.env.PUBLIC_URL + '/model/model.json');\n    //     let img = new Image();\n    //     const self = this;\n    //     img.onload = async function () {\n    //         canvas.height = img.height;\n    //         canvas.width = img.width;\n    //         ctx.drawImage(img, 0, 0, img.width, img.height);\n    //         await self.run(myYolo, canvas, ctx);\n    //     };\n    //     img.src = test_img;\n    // }\n    //\n    // async run(myYolo, canvas, ctx) {\n    //     const start = performance.now();\n    //     const boxes = await myYolo(canvas, {numClasses: 1, classNames: ['figure']});\n    //     const end = performance.now();\n    //     console.log(`Inference took ${end - start} ms`);\n    //     console.log(boxes);\n    //     boxes.map((box) => {\n    //         ctx.lineWidth = 2;\n    //         ctx.fillStyle = \"red\";\n    //         ctx.strokeStyle = \"red\";\n    //         ctx.rect(box[\"left\"], box[\"top\"], box[\"width\"], box[\"height\"]);\n    //         ctx.fillText(box[\"class\"], box[\"left\"] + 5, box[\"top\"] + 10);\n    //         ctx.stroke();\n    //         return box;\n    //     });\n    // }\n\n    render() {\n        return (\n            <div className=\"App\">\n                {/*<canvas id=\"canvas\"/>*/}\n                <WebCam/>\n            </div>\n        );\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = __webpack_public_path__ + \"static/media/img_45.dc0ae38d.jpg\";"],"sourceRoot":""}